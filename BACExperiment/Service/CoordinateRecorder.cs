using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Timers;
using System.Windows;
using System.Windows.Controls;

namespace BACExperiment
{
    /// <summary>
    /// The coordinateRecorder object handles the data saved into the CoordinateDataBuffer and saves it into session files.
    /// </summary>
    class coordinateRecorder
    {


        private System.Timers.Timer timer;
        private String directoryPath;// file path for the current sessionLogs
        private String logPath;
        private StreamWriter logstream;
        private Stopwatch watch;

        private static coordinateRecorder instance;

        private CoordinateDataBuffer buffer;


        //There is only one CoordinateHolder object per runtime.
        public static coordinateRecorder getInstance(MovementWindow observee)
        {
            if (instance == null)
                instance = new coordinateRecorder();

            return instance;
        }

        private coordinateRecorder()
        {
            buffer = CoordinateDataBuffer.GetInstance();

            directoryPath = System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location);
            watch = new Stopwatch();

            string fileName = DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss") + ".txt";
            logPath = System.IO.Path.Combine(SessionLogDirectoryPresent(), fileName);
            logstream = new StreamWriter(logPath, true);

            timer = new System.Timers.Timer();
            timer.Interval = 1;
            timer.Elapsed += new ElapsedEventHandler(Record);
        }

        /// <summary>
        /// Starts saving data from the CoordinateDataBuffer to the file. Starts imediatelly after calling and then records every 1/100th seconds. 
        /// </summary>
        ///It is possible that a delay is generated by the saving of coordinates into file.
        /// A different way of recording coordinates would be to create a buffer which is populated with the values and saved in file at the 
        /// end of the experiment.

        public void Run()
        {

            timer.Enabled = true;
            watch.Start();           
        }

        public void Stop()
        {
            timer.Enabled = false;
            watch.Stop();
        }


        //Test if there is a session File in the current assembly execution path . If not create a new one entirely.
        public string SessionLogDirectoryPresent()
        {
            if (!Directory.Exists(directoryPath + "\\Session Logs"))
            {
                Directory.CreateDirectory(directoryPath + "\\Session Logs");
            }

            return directoryPath + "\\Session Logs";
        }


        /// <summary>
        /// Record event trigered every 1/100 th second. Saves the coordinates curently present in the CoordinateHolder into the session file.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        public void Record(object sender, ElapsedEventArgs args)
        {
            if (timer.Interval <= 10)
                timer.Interval = 10;

            DateTime t = args.SignalTime; // Take the time the tick was done
            Point ellipseCoordiante = buffer.GetEllipseCoordinates();  // Parse coordinates from StimulyWindow to service and then to thread where they will be recorded into the log file
            Point controller1 = buffer.GetPointerCoordinates(0);
            Point controller2 = buffer.GetPointerCoordinates(1);
            double[,] accel = buffer.getAccelValues();
            string toWrite = string.Concat(watch.Elapsed.ToString(), ";", ellipseCoordiante.ToString(), ";", controller1.ToString(), ";", controller2.ToString(), ";",
                accel[0, 0], ";", accel[0, 1], ";", accel[0, 2], ";", accel[1, 0], ";", accel[1, 1], ";", accel[1, 2]);

            //TO-DO runtime error when attempting to write to file on Synchronous mode. 
                logstream.WriteLine(toWrite);
        }


        public void Clear()
        {
            instance = null;
        }


    }
}